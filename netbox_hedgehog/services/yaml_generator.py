"""
YAML Generation Service for Topology Plans (DIET-006)

This service generates Hedgehog wiring diagram YAML from a TopologyPlan.
It creates Connection CRDs for server-to-switch connections based on the
plan's server classes, switch classes, and connection specifications.
"""

import re
from typing import List, Dict, Any, Tuple
from collections import defaultdict

from ..models.topology_planning import (
    TopologyPlan,
    PlanServerClass,
    PlanSwitchClass,
    PlanServerConnection,
)
from ..choices import ConnectionTypeChoices, ConnectionDistributionChoices


class PortAllocator:
    """
    Tracks port allocation for switches to prevent duplicate assignments.

    Each switch has a limited number of ports, and this class ensures
    no port is assigned twice.
    """

    def __init__(self):
        """Initialize port allocation tracking"""
        self.allocated_ports: Dict[str, set] = defaultdict(set)
        self.next_port: Dict[str, int] = defaultdict(lambda: 1)

    def allocate(self, switch_name: str, port_count: int = 1) -> List[str]:
        """
        Allocate one or more ports on a switch.

        Args:
            switch_name: Name of the switch
            port_count: Number of consecutive ports to allocate

        Returns:
            List of allocated port names (e.g., ['E1/1', 'E1/2'])
        """
        allocated = []
        for _ in range(port_count):
            # Find next available port
            port_num = self.next_port[switch_name]
            port_name = f"E1/{port_num}"

            # Mark as allocated
            self.allocated_ports[switch_name].add(port_name)
            allocated.append(port_name)

            # Increment for next allocation
            self.next_port[switch_name] = port_num + 1

        return allocated


class YAMLGenerator:
    """
    Generates Hedgehog wiring YAML from a TopologyPlan.

    This class orchestrates the generation of Connection CRDs by:
    1. Creating switch instances from switch classes
    2. Creating server instances from server classes
    3. Generating connections for each server based on connection definitions
    4. Handling MCLAG and other advanced connection types
    """

    def __init__(self, plan: TopologyPlan):
        """
        Initialize the YAML generator for a specific plan.

        Args:
            plan: TopologyPlan instance to generate YAML for
        """
        self.plan = plan
        self.port_allocator = PortAllocator()

    def generate(self) -> str:
        """
        Generate complete Hedgehog wiring YAML for the plan.

        Returns:
            YAML string containing all Connection CRDs
        """
        import yaml

        # Generate all connection documents
        documents = []

        # Add header comment
        header_comment = (
            f"# Generated by Hedgehog NetBox Plugin - Topology Planner\n"
            f"# Plan: {self.plan.name}\n"
            f"# Customer: {self.plan.customer_name or 'N/A'}\n"
            f"# Generated: {self.plan.last_updated.isoformat() if hasattr(self.plan, 'last_updated') else 'N/A'}\n"
        )

        # Generate connections for each server class
        for server_class in self.plan.server_classes.all():
            connections = server_class.connections.all()

            for connection_def in connections:
                # Generate connections for each server in the class
                for server_idx in range(server_class.quantity):
                    server_name = self._generate_server_name(server_class, server_idx)

                    # Generate connections for this server
                    server_connections = self._generate_connections_for_server(
                        server_name,
                        server_class,
                        connection_def,
                        server_idx
                    )
                    documents.extend(server_connections)

        # Convert to YAML
        if not documents:
            # Return empty YAML if no connections
            return header_comment + "\n# No connections defined in this plan\n"

        # Serialize each document separately and combine
        yaml_parts = [header_comment]
        for doc in documents:
            yaml_str = yaml.dump(doc, default_flow_style=False, sort_keys=False)
            yaml_parts.append(yaml_str)

        return "---\n".join(yaml_parts)

    def _sanitize_name(self, name: str) -> str:
        """
        Sanitize a name to be DNS-label safe.

        DNS labels must:
        - Be lowercase
        - Contain only alphanumeric characters and hyphens
        - Start and end with alphanumeric characters
        - Be at most 63 characters long

        Args:
            name: Name to sanitize

        Returns:
            DNS-label safe name
        """
        # Convert to lowercase
        sanitized = name.lower()

        # Replace any non-alphanumeric (except hyphens) with hyphens
        sanitized = re.sub(r'[^a-z0-9-]', '-', sanitized)

        # Collapse multiple consecutive hyphens
        sanitized = re.sub(r'-+', '-', sanitized)

        # Remove leading/trailing hyphens
        sanitized = sanitized.strip('-')

        # Truncate to 63 characters
        if len(sanitized) > 63:
            sanitized = sanitized[:63].rstrip('-')

        return sanitized

    def _generate_server_name(self, server_class: PlanServerClass, index: int) -> str:
        """
        Generate a server name based on server class and index.

        Args:
            server_class: Server class
            index: Server index (0-based)

        Returns:
            Server name (e.g., 'gpu-001-001', 'gpu-001-002')
        """
        # Sanitize server class ID for use in name
        class_id = self._sanitize_name(server_class.server_class_id)

        # Pad index to 3 digits
        return f"{class_id}-{index+1:03d}"

    def _generate_switch_name(self, switch_class: PlanSwitchClass, index: int) -> str:
        """
        Generate a switch name based on switch class and index.

        Args:
            switch_class: Switch class
            index: Switch index (0-based)

        Returns:
            Switch name (e.g., 'fe-leaf-01', 'fe-leaf-02')
        """
        # Sanitize switch class ID for use in name
        class_id = self._sanitize_name(switch_class.switch_class_id)

        # Pad index to 2 digits
        return f"{class_id}-{index+1:02d}"

    def _generate_connections_for_server(
        self,
        server_name: str,
        server_class: PlanServerClass,
        connection_def: PlanServerConnection,
        server_idx: int
    ) -> List[Dict[str, Any]]:
        """
        Generate Connection CRDs for a single server's connection definition.

        Args:
            server_name: Name of the server
            server_class: Server class this server belongs to
            connection_def: Connection definition specifying how to connect
            server_idx: Index of this server within its class (for distribution)

        Returns:
            List of Connection CRD dictionaries
        """
        connections = []
        target_switch_class = connection_def.target_switch_class
        conn_type = connection_def.hedgehog_conn_type
        distribution = connection_def.distribution
        ports_per_connection = connection_def.ports_per_connection

        # Get switch instances for this connection
        switch_instances = self._get_switch_instances(target_switch_class)

        if not switch_instances:
            # No switches available - skip
            return []

        # Handle different connection types
        if conn_type == ConnectionTypeChoices.UNBUNDLED:
            connections = self._generate_unbundled_connections(
                server_name,
                connection_def,
                switch_instances,
                server_idx,
                ports_per_connection
            )
        elif conn_type == ConnectionTypeChoices.BUNDLED:
            connection = self._generate_bundled_connection(
                server_name,
                connection_def,
                switch_instances,
                server_idx,
                ports_per_connection
            )
            if connection:
                connections = [connection]
        elif conn_type == ConnectionTypeChoices.MCLAG:
            connection = self._generate_mclag_connection(
                server_name,
                connection_def,
                switch_instances,
                server_idx,
                ports_per_connection
            )
            if connection:
                connections = [connection]
        elif conn_type == ConnectionTypeChoices.ESLAG:
            connection = self._generate_eslag_connection(
                server_name,
                connection_def,
                switch_instances,
                server_idx,
                ports_per_connection
            )
            if connection:
                connections = [connection]

        return connections

    def _generate_unbundled_connections(
        self,
        server_name: str,
        connection_def: PlanServerConnection,
        switch_instances: List[str],
        server_idx: int,
        ports_per_connection: int
    ) -> List[Dict[str, Any]]:
        """Generate unbundled connection CRDs (one CRD per port)"""
        connections = []
        distribution = connection_def.distribution

        for port_idx in range(ports_per_connection):
            # Determine which switch this port connects to
            switch_name = self._select_switch_for_port(
                switch_instances,
                distribution,
                server_idx,
                port_idx
            )

            # Allocate a port on the selected switch
            switch_ports = self.port_allocator.allocate(switch_name, 1)
            switch_port = switch_ports[0]

            # Generate server port name
            server_port = self._generate_server_port_name(connection_def, port_idx)

            # Sanitize connection name for DNS-label safety
            conn_suffix = self._sanitize_name(
                connection_def.connection_name or connection_def.connection_id
            )

            # Create connection name
            conn_name = f"server--{server_name}--unbundled--{switch_name}--{conn_suffix}"
            # Append port index if multiple ports
            if ports_per_connection > 1:
                conn_name += f"-port{port_idx}"

            # Create connection document
            connection = {
                'apiVersion': 'wiring.githedgehog.com/v1beta1',
                'kind': 'Connection',
                'metadata': {
                    'name': conn_name,
                    'namespace': 'default'
                },
                'spec': {
                    'unbundled': {
                        'link': {
                            'server': {
                                'port': f"{server_name}/{server_port}"
                            },
                            'switch': {
                                'port': f"{switch_name}/{switch_port}"
                            }
                        }
                    }
                }
            }
            connections.append(connection)

        return connections

    def _generate_bundled_connection(
        self,
        server_name: str,
        connection_def: PlanServerConnection,
        switch_instances: List[str],
        server_idx: int,
        ports_per_connection: int
    ) -> Dict[str, Any]:
        """Generate a single bundled connection CRD with multiple links"""
        distribution = connection_def.distribution
        links = []

        for port_idx in range(ports_per_connection):
            # Determine which switch this port connects to
            switch_name = self._select_switch_for_port(
                switch_instances,
                distribution,
                server_idx,
                port_idx
            )

            # Allocate a port on the selected switch
            switch_ports = self.port_allocator.allocate(switch_name, 1)
            switch_port = switch_ports[0]

            # Generate server port name
            server_port = self._generate_server_port_name(connection_def, port_idx)

            # Add link
            links.append({
                'server': {
                    'port': f"{server_name}/{server_port}"
                },
                'switch': {
                    'port': f"{switch_name}/{switch_port}"
                }
            })

        # Sanitize connection name for DNS-label safety
        conn_suffix = self._sanitize_name(
            connection_def.connection_name or connection_def.connection_id
        )

        # Create connection name
        conn_name = f"server--{server_name}--bundled--{conn_suffix}"

        # Create connection document
        connection = {
            'apiVersion': 'wiring.githedgehog.com/v1beta1',
            'kind': 'Connection',
            'metadata': {
                'name': conn_name,
                'namespace': 'default'
            },
            'spec': {
                'bundled': {
                    'links': links
                }
            }
        }

        return connection

    def _generate_mclag_connection(
        self,
        server_name: str,
        connection_def: PlanServerConnection,
        switch_instances: List[str],
        server_idx: int,
        ports_per_connection: int
    ) -> Dict[str, Any]:
        """Generate an MCLAG connection CRD with alternating links across switch pair"""
        if len(switch_instances) < 2:
            # MCLAG requires at least 2 switches
            return None

        links = []

        # MCLAG connections alternate between the first two switches
        for port_idx in range(ports_per_connection):
            # Alternate between switch 0 and switch 1
            switch_name = switch_instances[port_idx % 2]

            # Allocate a port on the selected switch
            switch_ports = self.port_allocator.allocate(switch_name, 1)
            switch_port = switch_ports[0]

            # Generate server port name
            server_port = self._generate_server_port_name(connection_def, port_idx)

            # Add link
            links.append({
                'server': {
                    'port': f"{server_name}/{server_port}"
                },
                'switch': {
                    'port': f"{switch_name}/{switch_port}"
                }
            })

        # Sanitize connection name for DNS-label safety
        conn_suffix = self._sanitize_name(
            connection_def.connection_name or connection_def.connection_id
        )

        # Create connection name
        conn_name = f"server--{server_name}--mclag--{conn_suffix}"

        # Create connection document
        connection = {
            'apiVersion': 'wiring.githedgehog.com/v1beta1',
            'kind': 'Connection',
            'metadata': {
                'name': conn_name,
                'namespace': 'default'
            },
            'spec': {
                'mclag': {
                    'links': links
                }
            }
        }

        return connection

    def _generate_eslag_connection(
        self,
        server_name: str,
        connection_def: PlanServerConnection,
        switch_instances: List[str],
        server_idx: int,
        ports_per_connection: int
    ) -> Dict[str, Any]:
        """Generate an ESLAG connection CRD"""
        # ESLAG is similar to bundled but uses 'eslag' spec key
        links = []
        distribution = connection_def.distribution

        for port_idx in range(ports_per_connection):
            # Determine which switch this port connects to
            switch_name = self._select_switch_for_port(
                switch_instances,
                distribution,
                server_idx,
                port_idx
            )

            # Allocate a port on the selected switch
            switch_ports = self.port_allocator.allocate(switch_name, 1)
            switch_port = switch_ports[0]

            # Generate server port name
            server_port = self._generate_server_port_name(connection_def, port_idx)

            # Add link
            links.append({
                'server': {
                    'port': f"{server_name}/{server_port}"
                },
                'switch': {
                    'port': f"{switch_name}/{switch_port}"
                }
            })

        # Sanitize connection name for DNS-label safety
        conn_suffix = self._sanitize_name(
            connection_def.connection_name or connection_def.connection_id
        )

        # Create connection name
        conn_name = f"server--{server_name}--eslag--{conn_suffix}"

        # Create connection document
        connection = {
            'apiVersion': 'wiring.githedgehog.com/v1beta1',
            'kind': 'Connection',
            'metadata': {
                'name': conn_name,
                'namespace': 'default'
            },
            'spec': {
                'eslag': {
                    'links': links
                }
            }
        }

        return connection

    def _select_switch_for_port(
        self,
        switch_instances: List[str],
        distribution: str,
        server_idx: int,
        port_idx: int
    ) -> str:
        """
        Select which switch instance a port should connect to based on distribution strategy.

        Args:
            switch_instances: List of available switch names
            distribution: Distribution strategy
            server_idx: Index of the server within its class
            port_idx: Index of the port within the connection

        Returns:
            Name of the selected switch
        """
        if not switch_instances:
            raise ValueError("No switch instances available")

        if len(switch_instances) == 1:
            # Only one switch, use it
            return switch_instances[0]

        if distribution == ConnectionDistributionChoices.ALTERNATING:
            # Alternate ports between switches
            return switch_instances[port_idx % len(switch_instances)]
        elif distribution == ConnectionDistributionChoices.SAME_SWITCH:
            # All ports of a server go to the same switch
            # Distribute servers across switches
            return switch_instances[server_idx % len(switch_instances)]
        else:
            # Default: same-switch behavior
            return switch_instances[server_idx % len(switch_instances)]

    def _generate_server_port_name(self, connection_def: PlanServerConnection, port_idx: int) -> str:
        """
        Generate server port name based on NIC slot and port index.

        Args:
            connection_def: Connection definition
            port_idx: Port index (0-based)

        Returns:
            Port name (e.g., 'enp1s0f0', 'enp1s0f1')
        """
        # If NIC slot is specified, use it as base
        if connection_def.nic_slot:
            # Assume format like 'enp1s0' and append 'f{port_idx}'
            base = connection_def.nic_slot.rstrip('f0123456789')
            return f"{base}f{port_idx}"

        # Default: use connection_id and port index
        conn_id = re.sub(r'[^a-z0-9]', '', connection_def.connection_id.lower())
        return f"port-{conn_id}-{port_idx}"

    def _get_switch_instances(self, switch_class: PlanSwitchClass) -> List[str]:
        """
        Get list of switch instance names for a switch class.

        Args:
            switch_class: Switch class

        Returns:
            List of switch names (e.g., ['fe-leaf-01', 'fe-leaf-02'])
        """
        quantity = switch_class.effective_quantity
        if quantity == 0:
            return []

        return [
            self._generate_switch_name(switch_class, i)
            for i in range(quantity)
        ]


def generate_yaml_for_plan(plan: TopologyPlan) -> str:
    """
    Convenience function to generate YAML for a topology plan.

    Args:
        plan: TopologyPlan instance

    Returns:
        YAML string containing Connection CRDs
    """
    generator = YAMLGenerator(plan)
    return generator.generate()
