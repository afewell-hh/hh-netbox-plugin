"""
YAML Generation Service for Topology Plans (DIET-139)

This service generates Hedgehog wiring diagram YAML from NetBox inventory
(Devices, Interfaces, Cables) created by device generation.

IMPORTANT: This is an inventory-based export that reads actual NetBox objects,
NOT a plan-based generator. Port names come from Interface.name (authoritative).
"""

import re
from typing import Dict, Any, List
from collections import defaultdict
from django.core.exceptions import ValidationError

from dcim.models import Cable, Interface, Device

from ..models.topology_planning import TopologyPlan


class YAMLGenerator:
    """
    Generates Hedgehog wiring YAML from NetBox inventory (DIET-139).

    This is an inventory-based generator that reads from:
    - Devices (for role detection)
    - Interfaces (for port names with breakout suffixes)
    - Cables (for connections)

    All created by DeviceGenerator and tagged with hedgehog_plan_id.
    """

    def __init__(self, plan: TopologyPlan):
        """
        Initialize the YAML generator for a specific plan.

        Args:
            plan: TopologyPlan instance to generate YAML for
        """
        self.plan = plan

    def generate(self) -> str:
        """
        Generate complete Hedgehog wiring YAML from NetBox inventory (DIET-139).

        Reads Cables from NetBox and generates Connection CRDs with:
        - Exact Interface.name values (including breakout suffixes)
        - Deterministic ordering (by Cable ID)
        - Connection type detection (unbundled/fabric)
        - Cable validation (termination counts, role combinations)
        - Fabric link aggregation (multiple cables per leaf-spine pair)

        Returns:
            YAML string containing all Connection CRDs

        Raises:
            ValidationError: If cable topology is invalid
        """
        import yaml

        # Query cables from NetBox inventory (order by ID for determinism)
        cables = Cable.objects.filter(
            custom_field_data__hedgehog_plan_id=str(self.plan.pk)
        ).order_by('id')

        # Separate cables by connection type and aggregate fabric links
        unbundled_crds = []
        fabric_links_by_pair = defaultdict(list)  # (leaf_device, spine_device) -> [link_data]

        for cable in cables:
            try:
                conn_type, link_data = self._cable_to_link_data(cable)

                if conn_type == 'unbundled':
                    # Unbundled: one CRD per cable
                    unbundled_crds.append(self._create_unbundled_crd(link_data))

                elif conn_type == 'fabric':
                    # Fabric: aggregate by leaf-spine pair
                    device_pair = (link_data['leaf_device'], link_data['spine_device'])
                    fabric_links_by_pair[device_pair].append(link_data)

            except ValidationError as e:
                # Re-raise with cable ID context
                raise ValidationError(f"Cable {cable.id}: {str(e)}")

        # Generate fabric CRDs (one per leaf-spine pair with all links)
        fabric_crds = []
        for (leaf_device, spine_device), links in fabric_links_by_pair.items():
            fabric_crds.append(self._create_fabric_crd(leaf_device, spine_device, links))

        # Combine all documents (unbundled first, then fabric, both sorted by name)
        documents = sorted(unbundled_crds, key=lambda d: d['metadata']['name']) + \
                    sorted(fabric_crds, key=lambda d: d['metadata']['name'])

        # Build YAML output
        header_comment = (
            f"# Generated by Hedgehog NetBox Plugin - Topology Planner (DIET-139)\n"
            f"# Plan: {self.plan.name}\n"
            f"# Customer: {self.plan.customer_name or 'N/A'}\n"
            f"# Source: NetBox Inventory (Devices, Interfaces, Cables)\n"
            f"# Connection Count: {len(documents)}\n"
        )

        if not documents:
            return header_comment + "\n# No cables found in NetBox inventory for this plan\n"

        # Serialize each document separately and combine
        yaml_parts = [header_comment]
        for doc in documents:
            yaml_str = yaml.dump(doc, default_flow_style=False, sort_keys=False)
            yaml_parts.append(yaml_str)

        return "---\n".join(yaml_parts)

    def _cable_to_link_data(self, cable: Cable) -> tuple:
        """
        Extract connection type and link data from a NetBox Cable (DIET-139).

        Args:
            cable: Cable instance from NetBox inventory

        Returns:
            Tuple of (connection_type, link_data_dict)
            - connection_type: 'unbundled' or 'fabric'
            - link_data_dict: Contains device/interface info for the link

        Raises:
            ValidationError: If cable has invalid topology
        """
        # Validate cable terminations (NetBox 4.x returns lists, not querysets)
        a_terminations = cable.a_terminations if isinstance(cable.a_terminations, list) else list(cable.a_terminations.all())
        b_terminations = cable.b_terminations if isinstance(cable.b_terminations, list) else list(cable.b_terminations.all())

        # Check termination counts (single-termination only for MVP)
        if len(a_terminations) == 0 or len(b_terminations) == 0:
            raise ValidationError("Cable has missing terminations on one or both sides.")

        if len(a_terminations) > 1 or len(b_terminations) > 1:
            raise ValidationError(
                "Cable has multiple terminations on one side. Single-termination cables only."
            )

        # Check termination types (must be Interface objects)
        if not isinstance(a_terminations[0], Interface) or not isinstance(b_terminations[0], Interface):
            raise ValidationError("Cable terminations must be Interface objects.")

        iface_a = a_terminations[0]
        iface_b = b_terminations[0]

        # Get devices
        device_a = iface_a.device
        device_b = iface_b.device

        # Determine connection type and validate roles
        conn_type = self._determine_connection_type(device_a, device_b, cable.id)

        if conn_type == 'unbundled':
            # Server-switch connection
            # Determine which device is server vs switch
            if device_a.role.slug == 'server':
                server_device, server_iface = device_a, iface_a
                switch_device, switch_iface = device_b, iface_b
            else:
                server_device, server_iface = device_b, iface_b
                switch_device, switch_iface = device_a, iface_a

            return ('unbundled', {
                'server_device': server_device,
                'server_iface': server_iface,
                'switch_device': switch_device,
                'switch_iface': switch_iface,
            })

        elif conn_type == 'fabric':
            # Switch-switch connection (fabric)
            # Deterministic ordering: leaf/border before spine
            role_a = device_a.role.slug
            role_b = device_b.role.slug

            # Determine leaf vs spine
            if role_a in ('leaf', 'border') and role_b == 'spine':
                leaf_device, leaf_iface = device_a, iface_a
                spine_device, spine_iface = device_b, iface_b
            elif role_b in ('leaf', 'border') and role_a == 'spine':
                leaf_device, leaf_iface = device_b, iface_b
                spine_device, spine_iface = device_a, iface_a
            else:
                # Both same role - alphabetical by device name
                if device_a.name < device_b.name:
                    leaf_device, leaf_iface = device_a, iface_a
                    spine_device, spine_iface = device_b, iface_b
                else:
                    leaf_device, leaf_iface = device_b, iface_b
                    spine_device, spine_iface = device_a, iface_a

            return ('fabric', {
                'leaf_device': leaf_device,
                'leaf_iface': leaf_iface,
                'spine_device': spine_device,
                'spine_iface': spine_iface,
            })

        else:
            raise ValidationError(f"Unknown connection type: {conn_type}")

    def _create_unbundled_crd(self, link_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Create unbundled Connection CRD from link data.

        Args:
            link_data: Dictionary with server_device, server_iface, switch_device, switch_iface

        Returns:
            Connection CRD dictionary
        """
        server_device = link_data['server_device']
        server_iface = link_data['server_iface']
        switch_device = link_data['switch_device']
        switch_iface = link_data['switch_iface']

        # Generate CRD name (based on real-world example: server-03-fe-nic-1--unbundled--leaf-01)
        # MUST include server interface name to ensure uniqueness when multiple ports connect to same switch
        crd_name = self._sanitize_name(
            f"{server_device.name}-{server_iface.name}--unbundled--{switch_device.name}"
        )

        return {
            'apiVersion': 'wiring.githedgehog.com/v1beta1',
            'kind': 'Connection',
            'metadata': {
                'name': crd_name,
                'namespace': 'default',
            },
            'spec': {
                'unbundled': {
                    'link': {
                        'server': {
                            'port': f"{server_device.name}/{server_iface.name}",
                        },
                        'switch': {
                            'port': f"{switch_device.name}/{switch_iface.name}",
                        },
                    },
                },
            },
        }

    def _create_fabric_crd(
        self,
        leaf_device: Device,
        spine_device: Device,
        links: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """
        Create fabric Connection CRD aggregating multiple links (DIET-139).

        Args:
            leaf_device: Leaf switch device
            spine_device: Spine switch device
            links: List of link_data dicts for this leaf-spine pair

        Returns:
            Connection CRD dictionary with aggregated fabric links

        Note:
            IP addresses (leaf.ip, spine.ip) are NOT included in the wiring diagram.
            Hedgehog's hhfab utility automatically injects IP addresses during the
            fabric build process. This is the standard workflow - HNP does not assign IPs.
        """
        # Generate CRD name (based on real-world example: spine-02--fabric--border-leaf-01)
        crd_name = self._sanitize_name(
            f"{spine_device.name}--fabric--{leaf_device.name}"
        )

        # Build fabric links array (one entry per cable)
        # NOTE: No IP addresses - hhfab injects them automatically during build
        fabric_links = []
        for link_data in links:
            fabric_links.append({
                'leaf': {
                    'port': f"{link_data['leaf_device'].name}/{link_data['leaf_iface'].name}",
                    # 'ip' field omitted - hhfab injects during build
                },
                'spine': {
                    'port': f"{link_data['spine_device'].name}/{link_data['spine_iface'].name}",
                    # 'ip' field omitted - hhfab injects during build
                },
            })

        return {
            'apiVersion': 'wiring.githedgehog.com/v1beta1',
            'kind': 'Connection',
            'metadata': {
                'name': crd_name,
                'namespace': 'default',
            },
            'spec': {
                'fabric': {
                    'links': fabric_links,
                },
            },
        }

    def _determine_connection_type(self, device_a: Device, device_b: Device, cable_id: int) -> str:
        """
        Determine Hedgehog connection type from device roles (DIET-139).

        Args:
            device_a: First device
            device_b: Second device
            cable_id: Cable ID for error messages

        Returns:
            'unbundled' for server↔switch, 'fabric' for switch↔switch

        Raises:
            ValidationError: If role combination is invalid
        """
        role_a = device_a.role.slug
        role_b = device_b.role.slug

        # Define switch roles
        switch_roles = {'leaf', 'spine', 'border', 'oob'}

        # Server↔server is not supported
        if role_a == 'server' and role_b == 'server':
            raise ValidationError(
                "Server-to-server connections are not supported. "
                "Expected server↔switch or switch↔switch."
            )

        # Server↔switch → unbundled
        if role_a == 'server' and role_b in switch_roles:
            return 'unbundled'
        if role_b == 'server' and role_a in switch_roles:
            return 'unbundled'

        # Switch↔switch → fabric
        if role_a in switch_roles and role_b in switch_roles:
            return 'fabric'

        # Invalid combination
        raise ValidationError(
            f"Invalid device role combination: {role_a} ↔ {role_b}. "
            f"Expected server↔switch or switch↔switch."
        )

    def _sanitize_name(self, name: str) -> str:
        """
        Sanitize a name to be DNS-label safe.

        DNS labels must:
        - Be lowercase
        - Contain only alphanumeric characters and hyphens
        - Start and end with alphanumeric characters
        - Be at most 63 characters long

        Args:
            name: Name to sanitize

        Returns:
            DNS-label safe name
        """
        # Convert to lowercase
        sanitized = name.lower()

        # Replace any non-alphanumeric (except hyphens) with hyphens
        sanitized = re.sub(r'[^a-z0-9-]', '-', sanitized)

        # Collapse multiple consecutive hyphens
        sanitized = re.sub(r'-+', '-', sanitized)

        # Remove leading/trailing hyphens
        sanitized = sanitized.strip('-')

        # Truncate to 63 characters
        if len(sanitized) > 63:
            sanitized = sanitized[:63].rstrip('-')

        return sanitized


def generate_yaml_for_plan(plan: TopologyPlan) -> str:
    """
    Convenience function to generate YAML for a topology plan (DIET-139).

    This function reads from NetBox inventory (Devices, Interfaces, Cables)
    created by DeviceGenerator, NOT from the plan's class/connection definitions.

    Args:
        plan: TopologyPlan instance

    Returns:
        YAML string containing Connection CRDs from NetBox inventory

    Raises:
        ValidationError: If cable topology is invalid
    """
    generator = YAMLGenerator(plan)
    return generator.generate()
