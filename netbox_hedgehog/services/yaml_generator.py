"""
YAML Generation Service for Topology Plans (DIET-139)

This service generates Hedgehog wiring diagram YAML from NetBox inventory
(Devices, Interfaces, Cables) created by device generation.

IMPORTANT: This is an inventory-based export that reads actual NetBox objects,
NOT a plan-based generator. Port names come from Interface.name (authoritative).
"""

import re
from typing import Dict, Any, List
from collections import defaultdict
from django.core.exceptions import ValidationError

from dcim.models import Cable, Interface, Device

from ..models.topology_planning import TopologyPlan, DeviceTypeExtension


class YAMLGenerator:
    """
    Generates Hedgehog wiring YAML from NetBox inventory (DIET-139).

    This is an inventory-based generator that reads from:
    - Devices (for role detection)
    - Interfaces (for port names with breakout suffixes)
    - Cables (for connections)

    All created by DeviceGenerator and tagged with hedgehog_plan_id.
    """

    def __init__(self, plan: TopologyPlan):
        """
        Initialize the YAML generator for a specific plan.

        Args:
            plan: TopologyPlan instance to generate YAML for
        """
        self.plan = plan

    def generate(self) -> str:
        """
        Generate complete Hedgehog wiring YAML with all CRD types.

        CRD generation order matches Kubernetes/Hedgehog dependencies:
        1. Namespaces (VLANNamespace, IPv4Namespace)
        2. SwitchGroups (referenced by Switches)
        3. Switches (referenced by Connections)
        4. Servers (referenced by Connections)
        5. Connections (uses all above)

        Returns:
            YAML string containing all CRD types

        Raises:
            ValidationError: If cable topology or device configuration is invalid
        """
        import yaml

        # Step 1: Generate foundational CRDs
        vlannamespace_crds = self._generate_vlannamespaces()
        ipv4namespace_crds = self._generate_ipv4namespaces()

        # Step 2: Generate SwitchGroup CRDs (conditional)
        switchgroup_crds = self._generate_switchgroups()

        # Step 3: Generate device CRDs
        switch_crds = self._generate_switches()
        server_crds = self._generate_servers()

        # Step 4: Generate connection CRDs (existing logic, refactored)
        connection_crds = self._generate_connection_crds()

        # Step 5: Combine and order all documents
        documents = (
            sorted(vlannamespace_crds, key=lambda d: d['metadata']['name']) +
            sorted(ipv4namespace_crds, key=lambda d: d['metadata']['name']) +
            sorted(switchgroup_crds, key=lambda d: d['metadata']['name']) +
            sorted(switch_crds, key=lambda d: d['metadata']['name']) +
            sorted(server_crds, key=lambda d: d['metadata']['name']) +
            sorted(connection_crds, key=lambda d: d['metadata']['name'])
        )

        # Step 6: Build YAML with header
        header_comment = (
            f"# Generated by Hedgehog NetBox Plugin - Topology Planner (DIET-143)\n"
            f"# Plan: {self.plan.name}\n"
            f"# Customer: {self.plan.customer_name or 'N/A'}\n"
            f"# Source: NetBox Inventory (Devices, Interfaces, Cables)\n"
            f"# Total CRDs: {len(documents)}\n"
        )

        if not documents:
            return header_comment + "\n# No inventory found in NetBox for this plan\n"

        # Serialize each document separately and combine
        yaml_parts = [header_comment]
        for doc in documents:
            yaml_str = yaml.dump(doc, default_flow_style=False, sort_keys=False)
            yaml_parts.append(yaml_str)

        return "---\n".join(yaml_parts)

    def _cable_to_link_data(self, cable: Cable) -> tuple:
        """
        Extract connection type and link data from a NetBox Cable (DIET-139).

        Args:
            cable: Cable instance from NetBox inventory

        Returns:
            Tuple of (connection_type, link_data_dict)
            - connection_type: 'unbundled' or 'fabric'
            - link_data_dict: Contains device/interface info for the link

        Raises:
            ValidationError: If cable has invalid topology
        """
        # Validate cable terminations (NetBox 4.x returns lists, not querysets)
        a_terminations = cable.a_terminations if isinstance(cable.a_terminations, list) else list(cable.a_terminations.all())
        b_terminations = cable.b_terminations if isinstance(cable.b_terminations, list) else list(cable.b_terminations.all())

        # Check termination counts (single-termination only for MVP)
        if len(a_terminations) == 0 or len(b_terminations) == 0:
            raise ValidationError("Cable has missing terminations on one or both sides.")

        if len(a_terminations) > 1 or len(b_terminations) > 1:
            raise ValidationError(
                "Cable has multiple terminations on one side. Single-termination cables only."
            )

        # Check termination types (must be Interface objects)
        if not isinstance(a_terminations[0], Interface) or not isinstance(b_terminations[0], Interface):
            raise ValidationError("Cable terminations must be Interface objects.")

        iface_a = a_terminations[0]
        iface_b = b_terminations[0]

        # Get devices
        device_a = iface_a.device
        device_b = iface_b.device

        # Determine connection type and validate roles
        conn_type = self._determine_connection_type(device_a, device_b, cable.id)

        if conn_type == 'unbundled':
            # Server-switch connection
            # Determine which device is server vs switch
            if device_a.role.slug == 'server':
                server_device, server_iface = device_a, iface_a
                switch_device, switch_iface = device_b, iface_b
            else:
                server_device, server_iface = device_b, iface_b
                switch_device, switch_iface = device_a, iface_a

            return ('unbundled', {
                'server_device': server_device,
                'server_iface': server_iface,
                'switch_device': switch_device,
                'switch_iface': switch_iface,
            })

        elif conn_type == 'fabric':
            # Switch-switch connection (fabric)
            # Deterministic ordering: leaf/border before spine
            role_a = device_a.role.slug
            role_b = device_b.role.slug

            # Determine leaf vs spine
            if role_a in ('leaf', 'border') and role_b == 'spine':
                leaf_device, leaf_iface = device_a, iface_a
                spine_device, spine_iface = device_b, iface_b
            elif role_b in ('leaf', 'border') and role_a == 'spine':
                leaf_device, leaf_iface = device_b, iface_b
                spine_device, spine_iface = device_a, iface_a
            else:
                # Both same role - alphabetical by device name
                if device_a.name < device_b.name:
                    leaf_device, leaf_iface = device_a, iface_a
                    spine_device, spine_iface = device_b, iface_b
                else:
                    leaf_device, leaf_iface = device_b, iface_b
                    spine_device, spine_iface = device_a, iface_a

            return ('fabric', {
                'leaf_device': leaf_device,
                'leaf_iface': leaf_iface,
                'spine_device': spine_device,
                'spine_iface': spine_iface,
            })

        else:
            raise ValidationError(f"Unknown connection type: {conn_type}")

    def _create_unbundled_crd(self, link_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Create unbundled Connection CRD from link data.

        Args:
            link_data: Dictionary with server_device, server_iface, switch_device, switch_iface

        Returns:
            Connection CRD dictionary
        """
        server_device = link_data['server_device']
        server_iface = link_data['server_iface']
        switch_device = link_data['switch_device']
        switch_iface = link_data['switch_iface']

        # Generate CRD name (based on real-world example: server-03-fe-nic-1--unbundled--leaf-01)
        # MUST include server interface name to ensure uniqueness when multiple ports connect to same switch
        crd_name = self._sanitize_name(
            f"{server_device.name}-{server_iface.name}--unbundled--{switch_device.name}"
        )

        return {
            'apiVersion': 'wiring.githedgehog.com/v1beta1',
            'kind': 'Connection',
            'metadata': {
                'name': crd_name,
                'namespace': 'default',
            },
            'spec': {
                'unbundled': {
                    'link': {
                        'server': {
                            'port': f"{server_device.name}/{server_iface.name}",
                        },
                        'switch': {
                            'port': f"{switch_device.name}/{switch_iface.name}",
                        },
                    },
                },
            },
        }

    def _create_fabric_crd(
        self,
        leaf_device: Device,
        spine_device: Device,
        links: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """
        Create fabric Connection CRD aggregating multiple links (DIET-139).

        Args:
            leaf_device: Leaf switch device
            spine_device: Spine switch device
            links: List of link_data dicts for this leaf-spine pair

        Returns:
            Connection CRD dictionary with aggregated fabric links

        Note:
            IP addresses (leaf.ip, spine.ip) are NOT included in the wiring diagram.
            Hedgehog's hhfab utility automatically injects IP addresses during the
            fabric build process. This is the standard workflow - HNP does not assign IPs.
        """
        # Generate CRD name (based on real-world example: spine-02--fabric--border-leaf-01)
        crd_name = self._sanitize_name(
            f"{spine_device.name}--fabric--{leaf_device.name}"
        )

        # Build fabric links array (one entry per cable)
        # NOTE: No IP addresses - hhfab injects them automatically during build
        fabric_links = []
        for link_data in links:
            fabric_links.append({
                'leaf': {
                    'port': f"{link_data['leaf_device'].name}/{link_data['leaf_iface'].name}",
                    # 'ip' field omitted - hhfab injects during build
                },
                'spine': {
                    'port': f"{link_data['spine_device'].name}/{link_data['spine_iface'].name}",
                    # 'ip' field omitted - hhfab injects during build
                },
            })

        return {
            'apiVersion': 'wiring.githedgehog.com/v1beta1',
            'kind': 'Connection',
            'metadata': {
                'name': crd_name,
                'namespace': 'default',
            },
            'spec': {
                'fabric': {
                    'links': fabric_links,
                },
            },
        }

    def _determine_connection_type(self, device_a: Device, device_b: Device, cable_id: int) -> str:
        """
        Determine Hedgehog connection type from device roles (DIET-139).

        Args:
            device_a: First device
            device_b: Second device
            cable_id: Cable ID for error messages

        Returns:
            'unbundled' for server↔switch, 'fabric' for switch↔switch

        Raises:
            ValidationError: If role combination is invalid
        """
        role_a = device_a.role.slug
        role_b = device_b.role.slug

        # Define switch roles
        switch_roles = {'leaf', 'spine', 'border', 'oob'}

        # Server↔server is not supported
        if role_a == 'server' and role_b == 'server':
            raise ValidationError(
                "Server-to-server connections are not supported. "
                "Expected server↔switch or switch↔switch."
            )

        # Server↔switch → unbundled
        if role_a == 'server' and role_b in switch_roles:
            return 'unbundled'
        if role_b == 'server' and role_a in switch_roles:
            return 'unbundled'

        # Switch↔switch → fabric
        if role_a in switch_roles and role_b in switch_roles:
            return 'fabric'

        # Invalid combination
        raise ValidationError(
            f"Invalid device role combination: {role_a} ↔ {role_b}. "
            f"Expected server↔switch or switch↔switch."
        )

    def _sanitize_name(self, name: str) -> str:
        """
        Sanitize a name to be DNS-label safe.

        DNS labels must:
        - Be lowercase
        - Contain only alphanumeric characters and hyphens
        - Start and end with alphanumeric characters
        - Be at most 63 characters long

        Args:
            name: Name to sanitize

        Returns:
            DNS-label safe name
        """
        # Convert to lowercase
        sanitized = name.lower()

        # Replace any non-alphanumeric (except hyphens) with hyphens
        sanitized = re.sub(r'[^a-z0-9-]', '-', sanitized)

        # Collapse multiple consecutive hyphens
        sanitized = re.sub(r'-+', '-', sanitized)

        # Remove leading/trailing hyphens
        sanitized = sanitized.strip('-')

        # Truncate to 63 characters
        if len(sanitized) > 63:
            sanitized = sanitized[:63].rstrip('-')

        return sanitized

    def _generate_unique_crd_name(self, device: Device, existing_names: set) -> str:
        """
        Generate unique DNS-1123 compliant name with collision avoidance.

        Strategy:
        1. Sanitize device name to DNS-1123 format
        2. If unique, use as-is
        3. If collision, append device PK for guaranteed uniqueness

        Args:
            device: NetBox Device object (need name and pk)
            existing_names: Set of already-used CRD names (mutated by this method)

        Returns:
            Unique DNS-1123 label (max 63 chars)

        Example:
            Device(name="Server_01", pk=123) → "server-01"
            Device(name="Server-01", pk=124) (collision) → "server-01-124"
        """
        sanitized = self._sanitize_name(device.name)

        # If unique, return as-is
        if sanitized not in existing_names:
            existing_names.add(sanitized)
            return sanitized

        # Collision detected - add device PK suffix for guaranteed uniqueness
        suffix = str(device.pk)
        unique_name = f"{sanitized}-{suffix}"

        # Truncate if needed (max 63 chars for DNS label)
        if len(unique_name) > 63:
            # Keep suffix intact, truncate base
            max_base = 63 - len(suffix) - 1  # -1 for hyphen
            unique_name = f"{sanitized[:max_base]}-{suffix}"

        existing_names.add(unique_name)
        return unique_name

    def _map_netbox_role_to_hedgehog(self, device: Device) -> str:
        """
        Map NetBox device role to Hedgehog switch role.

        Priority:
        1. If device.custom_field_data['hedgehog_role'] is set, use it
        2. Otherwise map from device.role.slug

        Args:
            device: NetBox Device object

        Returns:
            Hedgehog role name (spine, server-leaf, border-leaf, mixed-leaf, virtual-edge)
        """
        # First check if hedgehog_role is explicitly set in custom fields
        hedgehog_role = device.custom_field_data.get('hedgehog_role')
        if hedgehog_role:
            return hedgehog_role

        # Fall back to role slug mapping
        mapping = {
            'spine': 'spine',
            'leaf': 'server-leaf',
            'border': 'border-leaf',
        }
        return mapping.get(device.role.slug, 'server-leaf')

    def _generate_switches(self) -> List[Dict[str, Any]]:
        """
        Generate Switch CRDs from NetBox Devices with switch roles.

        Reads:
        - Device.name, Device.role
        - custom_field_data['boot_mac']
        - device_type.devicetypeextension.hedgehog_profile_name

        Returns:
            List of Switch CRD dicts with spec: {role, profile, boot}
        """
        switch_crds = []
        existing_names = set()

        # Filter by plan ID and presence of hedgehog_role
        # Don't rely on NetBox role slugs - they may vary by installation
        switches = Device.objects.filter(
            custom_field_data__hedgehog_plan_id=str(self.plan.pk),
            custom_field_data__hedgehog_role__isnull=False
        ).exclude(
            custom_field_data__hedgehog_role=''
        ).select_related('device_type', 'role').order_by('id')

        for switch in switches:
            # Get unique CRD name (collision-safe)
            crd_name = self._generate_unique_crd_name(switch, existing_names)

            # Get profile name from device type extension
            try:
                device_type_ext = switch.device_type.devicetypeextension
                profile_name = device_type_ext.hedgehog_profile_name
                if not profile_name:
                    raise ValidationError(
                        f"Switch {switch.name} device type '{switch.device_type.model}' "
                        f"missing hedgehog_profile_name in DeviceTypeExtension"
                    )
            except DeviceTypeExtension.DoesNotExist:
                raise ValidationError(
                    f"Switch {switch.name} device type '{switch.device_type.model}' "
                    f"has no DeviceTypeExtension record"
                )

            # Get boot MAC from custom field
            boot_mac = switch.custom_field_data.get('boot_mac')
            if not boot_mac:
                raise ValidationError(
                    f"Switch {switch.name} missing boot_mac in custom_field_data"
                )

            # Build spec
            spec = {
                'role': self._map_netbox_role_to_hedgehog(switch),
                'profile': profile_name,
                'boot': {
                    'mac': boot_mac
                }
            }

            # MVP: Omit VTEPIP (Phase 2: VPC integration)
            # MVP: Omit portBreakouts/Speeds/AutoNegs (use profile defaults)

            switch_crds.append({
                'apiVersion': 'wiring.githedgehog.com/v1beta1',
                'kind': 'Switch',
                'metadata': {
                    'name': crd_name,
                    'namespace': 'default'
                },
                'spec': spec
            })

        return switch_crds

    def _generate_servers(self) -> List[Dict[str, Any]]:
        """
        Generate Server CRDs from NetBox Devices with server role.

        NOTE: Per authoritative schema, Server CRD spec includes only:
        - description (optional)
        - profile (optional, not used in MVP)

        Server interfaces are NOT included in Server CRD spec.
        Interfaces are referenced via Connection CRDs (unbundled/bundled/mclag).

        Reads:
        - Device.name, Device.comments

        Returns:
            List of Server CRD dicts with spec: {description}
        """
        server_crds = []
        existing_names = set()

        servers = Device.objects.filter(
            role__slug='server',
            custom_field_data__hedgehog_plan_id=str(self.plan.pk)
        ).order_by('id')

        for server in servers:
            # Get unique CRD name (collision-safe)
            crd_name = self._generate_unique_crd_name(server, existing_names)

            # Build minimal spec (description only per schema)
            spec = {}
            if server.comments:
                spec['description'] = server.comments

            server_crds.append({
                'apiVersion': 'wiring.githedgehog.com/v1beta1',
                'kind': 'Server',
                'metadata': {
                    'name': crd_name,
                    'namespace': 'default'
                },
                'spec': spec
            })

        return server_crds

    def _generate_connection_crds(self) -> List[Dict[str, Any]]:
        """
        Generate Connection CRDs from NetBox Cables (existing logic).

        Moved from generate() method for consistency with new architecture.

        Returns:
            List of Connection CRD dicts (unbundled + fabric)
        """
        # Query cables from NetBox inventory (order by ID for determinism)
        cables = Cable.objects.filter(
            custom_field_data__hedgehog_plan_id=str(self.plan.pk)
        ).order_by('id')

        # Separate cables by connection type and aggregate fabric links
        unbundled_crds = []
        fabric_links_by_pair = defaultdict(list)  # (leaf_device, spine_device) -> [link_data]

        for cable in cables:
            try:
                conn_type, link_data = self._cable_to_link_data(cable)

                if conn_type == 'unbundled':
                    # Unbundled: one CRD per cable
                    unbundled_crds.append(self._create_unbundled_crd(link_data))

                elif conn_type == 'fabric':
                    # Fabric: aggregate by leaf-spine pair
                    device_pair = (link_data['leaf_device'], link_data['spine_device'])
                    fabric_links_by_pair[device_pair].append(link_data)

            except ValidationError as e:
                # Re-raise with cable ID context
                raise ValidationError(f"Cable {cable.id}: {str(e)}")

        # Generate fabric CRDs (one per leaf-spine pair with all links)
        fabric_crds = []
        for (leaf_device, spine_device), links in fabric_links_by_pair.items():
            fabric_crds.append(self._create_fabric_crd(leaf_device, spine_device, links))

        return unbundled_crds + fabric_crds

    def _generate_vlannamespaces(self) -> List[Dict[str, Any]]:
        """
        Generate VLANNamespace CRDs for VLAN range allocation.

        MVP: Returns single "default" namespace with range 1000-2999.
        Future: Read from TopologyPlan.vlan_ranges or user configuration.

        Returns:
            List with one VLANNamespace CRD dict
        """
        return [{
            'apiVersion': 'wiring.githedgehog.com/v1beta1',
            'kind': 'VLANNamespace',
            'metadata': {
                'name': 'default',
                'namespace': 'default'
            },
            'spec': {
                'ranges': [
                    {'from': 1000, 'to': 2999}
                ]
            }
        }]

    def _generate_ipv4namespaces(self) -> List[Dict[str, Any]]:
        """
        Generate IPv4Namespace CRDs for IP subnet allocation.

        MVP: Returns single "default" namespace with 10.0.0.0/16 (matches production sample).
        Future: Read from TopologyPlan.ip_ranges or user configuration.

        Returns:
            List with one IPv4Namespace CRD dict
        """
        return [{
            'apiVersion': 'vpc.githedgehog.com/v1beta1',
            'kind': 'IPv4Namespace',
            'metadata': {
                'name': 'default',
                'namespace': 'default'
            },
            'spec': {
                'subnets': ['10.0.0.0/16']  # Match production sample
            }
        }]

    def _generate_switchgroups(self) -> List[Dict[str, Any]]:
        """
        Generate SwitchGroup CRDs for MCLAG/ESLAG redundancy groups.

        MVP: Returns empty list (MCLAG support deferred to Phase 2).

        Phase 2 implementation will:
        - Query PlanMCLAGDomain objects
        - Create one SwitchGroup per domain
        - Populate spec.type only (e.g., "mclag" or "eslag")

        NOTE: Per authoritative schema, SwitchGroup spec contains only:
        - type: string (mclag | eslag)
        Switch membership is tracked via Switch CRD spec.groups field, NOT in SwitchGroup.

        Returns:
            Empty list for MVP
        """
        # TODO: Phase 2 - MCLAG support
        return []


def generate_yaml_for_plan(plan: TopologyPlan) -> str:
    """
    Convenience function to generate YAML for a topology plan (DIET-139).

    This function reads from NetBox inventory (Devices, Interfaces, Cables)
    created by DeviceGenerator, NOT from the plan's class/connection definitions.

    Args:
        plan: TopologyPlan instance

    Returns:
        YAML string containing Connection CRDs from NetBox inventory

    Raises:
        ValidationError: If cable topology is invalid
    """
    generator = YAMLGenerator(plan)
    return generator.generate()
