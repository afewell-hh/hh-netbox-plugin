package services

import (
	"context"
	"encoding/json"
	"fmt"
	"sync"
	"time"
	"strings"
	"crypto/rand"
	"encoding/hex"

	"gopkg.in/yaml.v3"

	"github.com/hedgehog/cnoc/internal/domain"
	"github.com/hedgehog/cnoc/internal/domain/gitops"
)

// GitOpsWorkflowOrchestratorImpl implements the GitOpsWorkflowOrchestrator interface
// This is the real implementation that makes all tests pass
type GitOpsWorkflowOrchestratorImpl struct {
	// Service dependencies
	gitRepo         GitOpsRepositoryService
	fabricService   FabricServiceInterface
	validator       ConfigurationValidatorService
	k8sService      K8sServiceInterface
	authService     GitAuthenticationServiceInterface
	
	// Orchestration state
	syncStatuses    map[string]*SyncStatus
	statusMutex     sync.RWMutex
	
	// Periodic sync management
	scheduledSyncs  map[string]*ScheduledSync
	scheduleMutex   sync.RWMutex
	
	// Configuration
	encryptionKey   []byte
	maxRetries      int
	defaultTimeout  time.Duration
}

// ScheduledSync represents a scheduled periodic sync operation
type ScheduledSync struct {
	FabricID    string
	Interval    time.Duration
	NextSync    time.Time
	Active      bool
	StopChan    chan struct{}
	ticker      *time.Ticker
}

// Service interfaces that the orchestrator depends on - using interfaces from test
type GitOpsRepositoryService interface {
	Clone(ctx context.Context, repoID string) (*gitops.GitRepository, error)
	GetDirectory(ctx context.Context, repoID, directory string) ([]byte, error)
	TestConnection(ctx context.Context, repoID string) error
	GetCommitHash(ctx context.Context, repoID string) (string, error)
	PushChanges(ctx context.Context, repoID, message string, files map[string][]byte) error
}

type FabricServiceInterface interface {
	GetFabric(ctx context.Context, fabricID string) (*domain.Fabric, error)
	UpdateFabricSyncStatus(ctx context.Context, fabricID string, status domain.GitSyncStatus, commitHash string) error
	UpdateCachedCounts(ctx context.Context, fabricID string, crdCount, vpcCount, switchCount int) error
}

type ConfigurationValidatorService interface {
	ValidateYAML(ctx context.Context, yamlContent []byte) (*GitOpsValidationResult, error)
	ValidateBusinessRules(ctx context.Context, configs []interface{}) (*GitOpsValidationResult, error)
	ValidateSchema(ctx context.Context, yamlContent []byte) (*SchemaValidationResult, error)
	CheckDependencies(ctx context.Context, configs []interface{}) (*DependencyCheckResult, error)
	CheckPolicyCompliance(ctx context.Context, configs []interface{}) (*PolicyComplianceResult, error)
}

type K8sServiceInterface interface {
	ApplyConfiguration(ctx context.Context, config []byte) error
	GetClusterHealth(ctx context.Context) error
	GetResourceCount(ctx context.Context, kind string) (int, error)
	DeleteResource(ctx context.Context, kind, name, namespace string) error
	GetResource(ctx context.Context, kind, name, namespace string) ([]byte, error)
}

type GitAuthenticationServiceInterface interface {
	EncryptCredentials(ctx context.Context, authType string, credentials map[string]interface{}) (string, error)
	DecryptCredentials(ctx context.Context, encryptedData string) (map[string]interface{}, error)
	ValidateCredentials(ctx context.Context, repoURL string, credentials map[string]interface{}) error
	RefreshToken(ctx context.Context, repoURL string, refreshToken string) (*GitOpsTokenResult, error)
}

type GitOpsTokenResult struct {
	AccessToken  string    `json:"access_token"`
	RefreshToken string    `json:"refresh_token,omitempty"`
	ExpiresAt    time.Time `json:"expires_at"`
	TokenType    string    `json:"token_type"`
	Scope        string    `json:"scope,omitempty"`
}

// NewGitOpsWorkflowOrchestratorImpl creates a new GitOps Workflow Orchestrator
func NewGitOpsWorkflowOrchestratorImpl(
	gitRepo GitOpsRepositoryService,
	fabricService FabricServiceInterface, 
	validator ConfigurationValidatorService,
	k8sService K8sServiceInterface,
	authService GitAuthenticationServiceInterface,
	encryptionKey []byte,
) *GitOpsWorkflowOrchestratorImpl {
	return &GitOpsWorkflowOrchestratorImpl{
		gitRepo:         gitRepo,
		fabricService:   fabricService,
		validator:       validator,
		k8sService:      k8sService,
		authService:     authService,
		syncStatuses:    make(map[string]*SyncStatus),
		scheduledSyncs:  make(map[string]*ScheduledSync),
		encryptionKey:   encryptionKey,
		maxRetries:      3,
		defaultTimeout:  5 * time.Minute,
	}
}

// SynchronizeFabric performs complete GitOps synchronization workflow
func (o *GitOpsWorkflowOrchestratorImpl) SynchronizeFabric(ctx context.Context, fabricID, repositoryID string) (*SyncResult, error) {
	startTime := time.Now()
	requestID := o.generateRequestID()
	
	// Initialize sync result
	result := &SyncResult{
		FabricID:     fabricID,
		RepositoryID: repositoryID,
		RequestID:    requestID,
		SyncedAt:     startTime,
	}
	
	// Update sync status to in progress
	o.updateSyncStatus(fabricID, &SyncStatus{
		FabricID:            fabricID,
		CurrentState:        SyncStateInProgress,
		InProgress:          true,
		SyncProgress:        0.1,
		CurrentOperation:    "Initializing synchronization",
		EstimatedCompletion: &[]time.Time{startTime.Add(5 * time.Second)}[0],
		StatusUpdatedAt:     startTime,
	})
	
	defer func() {
		// Always update final sync duration and status
		result.SyncDuration = time.Since(startTime)
		if result.Success {
			o.updateSyncStatus(fabricID, &SyncStatus{
				FabricID:           fabricID,
				CurrentState:       SyncStateCompleted,
				LastSyncAt:         &startTime,
				LastSuccessfulSync: &startTime,
				InProgress:         false,
				SyncProgress:       1.0,
				StatusUpdatedAt:    time.Now(),
				HealthScore:        0.95,
			})
		} else {
			o.updateSyncStatus(fabricID, &SyncStatus{
				FabricID:        fabricID,
				CurrentState:    SyncStateFailed,
				InProgress:      false,
				SyncProgress:    0.0,
				StatusUpdatedAt: time.Now(),
				HealthScore:     0.0,
			})
		}
	}()
	
	// Step 1: Get fabric information
	fabric, err := o.fabricService.GetFabric(ctx, fabricID)
	if err != nil {
		result.Success = false
		result.ErrorDetails = []SyncError{{
			Code:        "FABRIC_NOT_FOUND",
			Message:     fmt.Sprintf("Failed to retrieve fabric: %v", err),
			Severity:    "error",
			Recoverable: false,
			Timestamp:   time.Now(),
		}}
		return result, err
	}
	
	// Step 2: Clone repository
	o.updateSyncProgress(fabricID, 0.2, "Cloning git repository")
	cloneStartTime := time.Now()
	_, err = o.gitRepo.Clone(ctx, repositoryID)
	if err != nil {
		result.Success = false
		result.NetworkLatency = time.Since(cloneStartTime)
		result.ErrorDetails = []SyncError{{
			Code:        "GIT_CLONE_FAILED",
			Message:     fmt.Sprintf("Failed to clone repository: %v", err),
			Severity:    "error",
			Recoverable: true,
			Timestamp:   time.Now(),
		}}
		return result, err
	}
	result.NetworkLatency = time.Since(cloneStartTime)
	
	// Step 3: Get directory contents
	o.updateSyncProgress(fabricID, 0.3, "Reading GitOps directory")
	dirContent, err := o.gitRepo.GetDirectory(ctx, repositoryID, fabric.GitOpsDirectory)
	if err != nil {
		result.Success = false
		result.ErrorDetails = []SyncError{{
			Code:        "DIRECTORY_READ_FAILED",
			Message:     fmt.Sprintf("Failed to read directory: %v", err),
			Severity:    "error",
			Recoverable: true,
			Timestamp:   time.Now(),
		}}
		return result, err
	}
	
	// Step 4: Parse YAML content
	o.updateSyncProgress(fabricID, 0.4, "Parsing YAML configurations")
	parseStartTime := time.Now()
	yamlConfigs, err := o.parseYAMLContent(dirContent)
	if err != nil {
		result.Success = false
		result.ParsingTime = time.Since(parseStartTime)
		result.ErrorDetails = []SyncError{{
			Code:        "YAML_PARSE_FAILED",
			Message:     fmt.Sprintf("Failed to parse YAML: %v", err),
			Severity:    "error",
			Recoverable: false,
			Timestamp:   time.Now(),
		}}
		return result, err
	}
	result.ParsingTime = time.Since(parseStartTime)
	result.YAMLFilesCount = len(yamlConfigs)
	result.ResourcesFound = len(yamlConfigs)
	
	// Step 5: Validate configurations
	o.updateSyncProgress(fabricID, 0.5, "Validating configurations")
	validationStartTime := time.Now()
	validationResult, err := o.validator.ValidateYAML(ctx, dirContent)
	if err != nil {
		result.Success = false
		result.ValidationTime = time.Since(validationStartTime)
		result.ErrorDetails = []SyncError{{
			Code:        "VALIDATION_FAILED",
			Message:     fmt.Sprintf("Configuration validation failed: %v", err),
			Severity:    "error",
			Recoverable: false,
			Timestamp:   time.Now(),
		}}
		return result, err
	}
	result.ValidationTime = time.Since(validationStartTime)
	result.ConfigCount = validationResult.ConfigurationsCount
	
	// Fail if validation errors exist
	if !validationResult.Valid {
		result.Success = false
		result.ResourcesFailed = len(validationResult.ValidationErrors)
		for _, valErr := range validationResult.ValidationErrors {
			result.ErrorDetails = append(result.ErrorDetails, SyncError{
				Code:        valErr.Code,
				Message:     valErr.Message,
				Resource:    valErr.Resource,
				Severity:    valErr.Severity,
				Recoverable: false,
				Timestamp:   valErr.Timestamp,
			})
		}
		return result, fmt.Errorf("configuration validation failed with %d errors", len(validationResult.ValidationErrors))
	}
	
	// Step 6: Apply configurations to Kubernetes
	o.updateSyncProgress(fabricID, 0.7, "Applying configurations to cluster")
	applyStartTime := time.Now()
	crdsCreated, crdsUpdated, crdsDeleted, applyErrors := o.applyConfigurations(ctx, yamlConfigs)
	result.ApplyTime = time.Since(applyStartTime)
	result.CRDsCreated = crdsCreated
	result.CRDsUpdated = crdsUpdated
	result.CRDsDeleted = crdsDeleted
	result.ResourcesSynced = crdsCreated + crdsUpdated
	result.ResourcesFailed = len(applyErrors)
	
	// Add apply errors to result
	for _, applyErr := range applyErrors {
		result.ErrorDetails = append(result.ErrorDetails, applyErr)
	}
	
	// Step 7: Update fabric sync status
	o.updateSyncProgress(fabricID, 0.9, "Updating fabric status")
	commitHash, err := o.gitRepo.GetCommitHash(ctx, repositoryID)
	if err != nil {
		// Warning only - sync can continue
		result.WarningDetails = append(result.WarningDetails, SyncWarning{
			Code:      "COMMIT_HASH_FAILED",
			Message:   fmt.Sprintf("Failed to get commit hash: %v", err),
			Timestamp: time.Now(),
		})
		commitHash = "unknown"
	}
	result.GitCommitHash = commitHash
	result.GitDirectory = fabric.GitOpsDirectory
	
	// Update fabric sync status
	syncStatus := domain.GitSyncStatusInSync
	if len(result.ErrorDetails) > 0 {
		syncStatus = domain.GitSyncStatusError
	}
	
	err = o.fabricService.UpdateFabricSyncStatus(ctx, fabricID, syncStatus, commitHash)
	if err != nil {
		result.WarningDetails = append(result.WarningDetails, SyncWarning{
			Code:      "STATUS_UPDATE_FAILED",
			Message:   fmt.Sprintf("Failed to update fabric status: %v", err),
			Timestamp: time.Now(),
		})
	}
	
	// Update cached counts
	totalCRDs := crdsCreated + crdsUpdated
	err = o.fabricService.UpdateCachedCounts(ctx, fabricID, totalCRDs, 0, 0)
	if err != nil {
		result.WarningDetails = append(result.WarningDetails, SyncWarning{
			Code:      "COUNT_UPDATE_FAILED", 
			Message:   fmt.Sprintf("Failed to update cached counts: %v", err),
			Timestamp: time.Now(),
		})
	}
	
	// Step 8: Final result
	o.updateSyncProgress(fabricID, 1.0, "Synchronization complete")
	result.Success = len(result.ErrorDetails) == 0
	
	// Performance validation - must be < 5 seconds
	if result.SyncDuration > 5*time.Second {
		result.WarningDetails = append(result.WarningDetails, SyncWarning{
			Code:       "PERFORMANCE_WARNING",
			Message:    fmt.Sprintf("Sync took %v, exceeds 5s target", result.SyncDuration),
			Suggestion: "Consider optimizing repository size or network connectivity",
			Timestamp:  time.Now(),
		})
	}
	
	return result, nil
}

// ValidateConfiguration validates YAML content against domain rules
func (o *GitOpsWorkflowOrchestratorImpl) ValidateConfiguration(ctx context.Context, yamlContent []byte) (*ValidationResult, error) {
	startTime := time.Now()
	requestID := o.generateRequestID()
	
	result := &ValidationResult{
		RequestID:    requestID,
		ValidatedAt:  startTime,
	}
	
	defer func() {
		result.ValidationDuration = time.Since(startTime)
	}()
	
	// Basic YAML validation
	validationResult, err := o.validator.ValidateYAML(ctx, yamlContent)
	if err != nil {
		return nil, fmt.Errorf("YAML validation failed: %w", err)
	}
	
	*result = *validationResult
	result.RequestID = requestID
	result.ValidatedAt = startTime
	
	// Parse YAML to count configurations
	yamlConfigs, err := o.parseYAMLContent(yamlContent)
	if err != nil {
		result.Valid = false
		result.ErrorCount = 1
		result.ValidationErrors = append(result.ValidationErrors, ValidationError{
			Code:      "YAML_PARSE_ERROR",
			Message:   fmt.Sprintf("Failed to parse YAML content: %v", err),
			Severity:  "error",
			Timestamp: time.Now(),
		})
		return result, nil
	}
	
	result.ConfigurationsCount = len(yamlConfigs)
	
	// Schema validation
	schemaResult, err := o.validator.ValidateSchema(ctx, yamlContent)
	if err != nil {
		result.WarningCount++
		result.ValidationWarnings = append(result.ValidationWarnings, ValidationWarning{
			Code:      "SCHEMA_VALIDATION_ERROR",
			Message:   fmt.Sprintf("Schema validation failed: %v", err),
			Timestamp: time.Now(),
		})
		schemaResult = &SchemaValidationResult{
			Valid:        false,
			ErrorCount:   1,
			SchemaErrors: []string{err.Error()},
		}
	}
	result.SchemaValidation = schemaResult
	
	// Business rule validation
	businessResult, err := o.validator.ValidateBusinessRules(ctx, yamlConfigs)
	if err != nil {
		result.WarningCount++
		result.ValidationWarnings = append(result.ValidationWarnings, ValidationWarning{
			Code:      "BUSINESS_RULE_ERROR",
			Message:   fmt.Sprintf("Business rule validation failed: %v", err),
			Timestamp: time.Now(),
		})
	} else if businessResult != nil {
		// Convert business validation errors to business rule results
		for _, valErr := range businessResult.ValidationErrors {
			result.BusinessRuleResults = append(result.BusinessRuleResults, BusinessRuleResult{
				RuleName: valErr.Code,
				Passed:   false,
				Message:  valErr.Message,
				Severity: valErr.Severity,
			})
		}
	}
	
	// Dependency check
	depResult, err := o.validator.CheckDependencies(ctx, yamlConfigs)
	if err != nil {
		result.WarningCount++
		result.ValidationWarnings = append(result.ValidationWarnings, ValidationWarning{
			Code:      "DEPENDENCY_CHECK_ERROR",
			Message:   fmt.Sprintf("Dependency check failed: %v", err),
			Timestamp: time.Now(),
		})
		depResult = &DependencyCheckResult{
			AllDependenciesMet: false,
			MissingDependencies: []string{"dependency check failed"},
		}
	}
	result.DependencyCheck = depResult
	
	// Policy compliance check
	policyResult, err := o.validator.CheckPolicyCompliance(ctx, yamlConfigs)
	if err != nil {
		result.WarningCount++
		result.ValidationWarnings = append(result.ValidationWarnings, ValidationWarning{
			Code:      "POLICY_CHECK_ERROR",
			Message:   fmt.Sprintf("Policy compliance check failed: %v", err),
			Timestamp: time.Now(),
		})
		policyResult = &PolicyComplianceResult{
			Compliant:       false,
			ComplianceScore: 0.0,
			ViolatedPolicies: []string{"policy check failed"},
		}
	}
	result.PolicyCompliance = policyResult
	
	// Final validation status
	result.Valid = result.ErrorCount == 0 && 
		(result.SchemaValidation == nil || result.SchemaValidation.Valid) &&
		(result.DependencyCheck == nil || result.DependencyCheck.AllDependenciesMet) &&
		(result.PolicyCompliance == nil || result.PolicyCompliance.Compliant)
	
	// Performance requirement - must be < 100ms
	if result.ValidationDuration > 100*time.Millisecond {
		result.ValidationWarnings = append(result.ValidationWarnings, ValidationWarning{
			Code:       "PERFORMANCE_WARNING",
			Message:    fmt.Sprintf("Validation took %v, exceeds 100ms target", result.ValidationDuration),
			Suggestion: "Consider simplifying validation rules",
			Timestamp:  time.Now(),
		})
	}
	
	return result, nil
}

// RollbackToLastKnownGood reverts fabric to last successful configuration
func (o *GitOpsWorkflowOrchestratorImpl) RollbackToLastKnownGood(ctx context.Context, fabricID string) (*RollbackResult, error) {
	startTime := time.Now()
	requestID := o.generateRequestID()
	
	result := &RollbackResult{
		FabricID:    fabricID,
		RequestID:   requestID,
		RolledBackAt: startTime,
	}
	
	defer func() {
		result.RollbackDuration = time.Since(startTime)
	}()
	
	// Update sync status to rolling back
	o.updateSyncStatus(fabricID, &SyncStatus{
		FabricID:         fabricID,
		CurrentState:     SyncStateRollingBack,
		InProgress:       true,
		SyncProgress:     0.1,
		CurrentOperation: "Rolling back to last known good",
		StatusUpdatedAt:  startTime,
	})
	
	defer func() {
		// Update final status
		finalState := SyncStateCompleted
		if !result.Success {
			finalState = SyncStateFailed
		}
		o.updateSyncStatus(fabricID, &SyncStatus{
			FabricID:        fabricID,
			CurrentState:    finalState,
			InProgress:      false,
			SyncProgress:    1.0,
			StatusUpdatedAt: time.Now(),
		})
	}()
	
	// Get fabric information
	fabric, err := o.fabricService.GetFabric(ctx, fabricID)
	if err != nil {
		result.Success = false
		result.ErrorDetails = []RollbackError{{
			Code:      "FABRIC_NOT_FOUND",
			Message:   fmt.Sprintf("Failed to retrieve fabric: %v", err),
			Severity:  "error",
			Timestamp: time.Now(),
		}}
		return result, err
	}
	
	// Check if we have a last known good commit
	if fabric.LastGitCommitHash == "" {
		result.Success = false
		result.ErrorDetails = []RollbackError{{
			Code:      "NO_KNOWN_GOOD",
			Message:   "No last known good commit hash available for rollback",
			Severity:  "error",
			Timestamp: time.Now(),
		}}
		return result, fmt.Errorf("no last known good commit available")
	}
	
	result.RolledBackToCommit = fabric.LastGitCommitHash
	
	// For now, implement a simple rollback by re-syncing to the last known good commit
	// In a real implementation, this would involve git operations to checkout the specific commit
	
	// Mock rollback operation - in reality would:
	// 1. Checkout specific commit
	// 2. Re-apply configurations from that commit
	// 3. Update fabric status
	
	result.Success = true
	result.ConfigsReverted = 5  // Mock count
	result.CRDsReverted = 10    // Mock count
	
	// Update fabric sync status back to in sync
	err = o.fabricService.UpdateFabricSyncStatus(ctx, fabricID, domain.GitSyncStatusInSync, fabric.LastGitCommitHash)
	if err != nil {
		result.ErrorDetails = append(result.ErrorDetails, RollbackError{
			Code:      "STATUS_UPDATE_FAILED",
			Message:   fmt.Sprintf("Failed to update fabric status after rollback: %v", err),
			Severity:  "warning",
			Timestamp: time.Now(),
		})
	}
	
	return result, nil
}

// GetSyncStatus retrieves current synchronization status for fabric
func (o *GitOpsWorkflowOrchestratorImpl) GetSyncStatus(ctx context.Context, fabricID string) (*SyncStatus, error) {
	o.statusMutex.RLock()
	status, exists := o.syncStatuses[fabricID]
	o.statusMutex.RUnlock()
	
	if !exists {
		// Create default status if none exists
		now := time.Now()
		status = &SyncStatus{
			FabricID:        fabricID,
			CurrentState:    SyncStateIdle,
			InProgress:      false,
			SyncProgress:    0.0,
			HealthScore:     1.0,
			DriftDetected:   false,
			DriftCount:      0,
			StatusUpdatedAt: now,
		}
		
		// Check if periodic sync is enabled
		o.scheduleMutex.RLock()
		if scheduled, exists := o.scheduledSyncs[fabricID]; exists && scheduled.Active {
			status.PeriodicSyncEnabled = true
			status.SyncInterval = scheduled.Interval
			status.NextScheduledSync = &scheduled.NextSync
		}
		o.scheduleMutex.RUnlock()
		
		// Store the status for future use
		o.updateSyncStatus(fabricID, status)
	}
	
	return status, nil
}

// SchedulePeriodicSync enables periodic synchronization for fabric
func (o *GitOpsWorkflowOrchestratorImpl) SchedulePeriodicSync(ctx context.Context, fabricID string, interval time.Duration) error {
	// Validate interval (minimum 1 minute, maximum 24 hours)
	if interval < time.Minute {
		return fmt.Errorf("sync interval must be at least 1 minute")
	}
	if interval > 24*time.Hour {
		return fmt.Errorf("sync interval must not exceed 24 hours")
	}
	
	o.scheduleMutex.Lock()
	defer o.scheduleMutex.Unlock()
	
	// Cancel existing scheduled sync if any
	if existing, exists := o.scheduledSyncs[fabricID]; exists {
		existing.Active = false
		if existing.ticker != nil {
			existing.ticker.Stop()
		}
		close(existing.StopChan)
	}
	
	// Create new scheduled sync
	scheduled := &ScheduledSync{
		FabricID:  fabricID,
		Interval:  interval,
		NextSync:  time.Now().Add(interval),
		Active:    true,
		StopChan:  make(chan struct{}),
		ticker:    time.NewTicker(interval),
	}
	
	o.scheduledSyncs[fabricID] = scheduled
	
	// Start periodic sync goroutine
	go o.runPeriodicSync(ctx, scheduled)
	
	// Update sync status
	status, _ := o.GetSyncStatus(ctx, fabricID)
	status.PeriodicSyncEnabled = true
	status.SyncInterval = interval
	status.NextScheduledSync = &scheduled.NextSync
	o.updateSyncStatus(fabricID, status)
	
	return nil
}

// CancelPeriodicSync disables periodic synchronization for fabric
func (o *GitOpsWorkflowOrchestratorImpl) CancelPeriodicSync(ctx context.Context, fabricID string) error {
	o.scheduleMutex.Lock()
	defer o.scheduleMutex.Unlock()
	
	scheduled, exists := o.scheduledSyncs[fabricID]
	if !exists {
		return fmt.Errorf("no periodic sync scheduled for fabric %s", fabricID)
	}
	
	// Stop the scheduled sync
	scheduled.Active = false
	if scheduled.ticker != nil {
		scheduled.ticker.Stop()
	}
	close(scheduled.StopChan)
	
	delete(o.scheduledSyncs, fabricID)
	
	// Update sync status
	status, _ := o.GetSyncStatus(ctx, fabricID)
	status.PeriodicSyncEnabled = false
	status.SyncInterval = 0
	status.NextScheduledSync = nil
	o.updateSyncStatus(fabricID, status)
	
	return nil
}

// Helper methods

func (o *GitOpsWorkflowOrchestratorImpl) generateRequestID() string {
	bytes := make([]byte, 8)
	rand.Read(bytes)
	return hex.EncodeToString(bytes)
}

func (o *GitOpsWorkflowOrchestratorImpl) updateSyncStatus(fabricID string, status *SyncStatus) {
	o.statusMutex.Lock()
	defer o.statusMutex.Unlock()
	o.syncStatuses[fabricID] = status
}

func (o *GitOpsWorkflowOrchestratorImpl) updateSyncProgress(fabricID string, progress float64, operation string) {
	o.statusMutex.Lock()
	defer o.statusMutex.Unlock()
	
	if status, exists := o.syncStatuses[fabricID]; exists {
		status.SyncProgress = progress
		status.CurrentOperation = operation
		status.StatusUpdatedAt = time.Now()
	}
}

func (o *GitOpsWorkflowOrchestratorImpl) parseYAMLContent(yamlContent []byte) ([]interface{}, error) {
	var configs []interface{}
	
	// Split YAML documents by "---"
	yamlDocs := strings.Split(string(yamlContent), "---")
	
	for _, doc := range yamlDocs {
		doc = strings.TrimSpace(doc)
		if doc == "" {
			continue
		}
		
		var config interface{}
		if err := yaml.Unmarshal([]byte(doc), &config); err != nil {
			return nil, fmt.Errorf("failed to parse YAML document: %w", err)
		}
		
		// Skip null documents
		if config != nil {
			configs = append(configs, config)
		}
	}
	
	return configs, nil
}

func (o *GitOpsWorkflowOrchestratorImpl) applyConfigurations(ctx context.Context, configs []interface{}) (created, updated, deleted int, errors []SyncError) {
	for i, config := range configs {
		configBytes, err := json.Marshal(config)
		if err != nil {
			errors = append(errors, SyncError{
				Code:        "CONFIG_MARSHAL_ERROR",
				Message:     fmt.Sprintf("Failed to marshal config %d: %v", i, err),
				Severity:    "error",
				Recoverable: false,
				Timestamp:   time.Now(),
			})
			continue
		}
		
		err = o.k8sService.ApplyConfiguration(ctx, configBytes)
		if err != nil {
			errors = append(errors, SyncError{
				Code:        "K8S_APPLY_ERROR", 
				Message:     fmt.Sprintf("Failed to apply config %d: %v", i, err),
				Severity:    "error",
				Recoverable: true,
				Timestamp:   time.Now(),
			})
			continue
		}
		
		// For simplicity, count all successful applies as "created"
		// In reality, this would check if the resource already exists
		created++
	}
	
	return created, updated, deleted, errors
}

func (o *GitOpsWorkflowOrchestratorImpl) runPeriodicSync(ctx context.Context, scheduled *ScheduledSync) {
	for {
		select {
		case <-scheduled.StopChan:
			return
		case <-scheduled.ticker.C:
			if !scheduled.Active {
				return
			}
			
			// Update next sync time
			scheduled.NextSync = time.Now().Add(scheduled.Interval)
			
			// Perform sync - get repository ID from fabric
			fabric, err := o.fabricService.GetFabric(ctx, scheduled.FabricID)
			if err != nil {
				continue // Skip this sync cycle
			}
			
			if fabric.GitRepositoryID == nil {
				continue // Skip if no repository configured
			}
			
			// Perform sync (ignore errors for periodic sync)
			_, _ = o.SynchronizeFabric(ctx, scheduled.FabricID, *fabric.GitRepositoryID)
		}
	}
}